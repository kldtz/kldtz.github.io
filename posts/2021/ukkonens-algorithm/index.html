<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    
    <meta name="description" content="An example for the construction of suffix trees in linear time accompanying Ukkonen (1995).">
    
    <title>Ukkonen's Algorithm for Suffix Trees</title>
    <link rel="alternate" type="application/rss+xml" href="https://proceed-to-decode.com/rss.xml"
        title="Proceed to Decode">
    <link rel="stylesheet" href="/css/default.css">
    
    
    
    
    
    
</head>

<body>
    <nav class="top-menu">
    <div class="top-menu">
        <ul class="left-menu">
            <li class="menu-item"><a href="/">Home</a></li>
            <li class="menu-item"><a href="/about">About</a></li>
        </ul>
        <ul class="right-menu">
            <li class="menu-item"><a href="https://github.com/kldtz"><img class="icon" src="/img/github_icon.svg"
                        alt="GitHub icon"></a></li>
            <li class="menu-item"><a href="/rss.xml"><img class="icon" src="/img/rss_icon.svg" alt="RSS icon"></a></li>
        </ul>
    </div>
</nav>
    <main>
        <article>
            <header>
                <h1>Ukkonen's Algorithm for Suffix Trees</h1>
                <div class="date"><span class="date">Mar 14, 2021</span></div>
            </header>
            <p>This post walks through an example of linear-time suffix tree construction to ease the understanding and implementation of Ukkonen (1995). I assume that you have the paper at hand, so I can refer to it and don't need to introduce all the terminology and every detail of the full algorithm from scratch.</p>
<p>When I decided to implement the algorithm, I first read Gusfield's (1997) chapter on <em>the linear-time construction of suffix trees</em>, because I saw it cited a lot and thought I could cut a corner using an easier description instead of the original paper. However, I found the chapter rather difficult to follow: for didactic reasons, it starts with a cubic-time version of the algorithm (although the naive approach is quadratic), it introduces some verbose and unintuitive terminology, and illustrates steps with confusing tree diagrams. After that I read Ukkonen's original paper and found it much clearer.<a id="fn-1"></a><sup><a href="#1">1</a></sup> With a few variable definitions scribbled on the margins of my copy, it was straightforward to implement a basic working <a href="https://gist.github.com/kldtz/ab8f26ca7ded84bf84773fe40b9ae828">version in Python</a>.</p>
<p>The algorithm moves over each character from left to right. While doing so, it maintains a <em>canonical reference pair</em> to the state which represents the longest suffix from the previous step that occured at least twice, the <em>active point</em>. The canonical reference pair of an explicit state consists of the state itself and the empty string. The canonical reference pair of an implicit state consists of its closest explicit ancestor and the string spelled out by the transition between this explicit ancestor state and the implicit state. In each step <em>i</em>, we walk the <em>boundary path</em> from the active state until we reach the <em>end point</em>, a state with a <em>t<sub>i</sub></em>-transition, where <em>t<sub>i</sub></em> is the character at index <em>i</em>.</p>
<h2>Constructing the tree</h2>
<p>We will construct the suffix tree for the string <em>abaabcab#</em>. For each step you'll find a visualization of the intermediate tree structure and a dry, repetitive description of what is happening. Circles represent states, arrows transitions. The state numbers indicate the order in which the states were created. Each edge is labeled with the transition's start and end indices (one-based) and the corresponding characters. Blue arrows represent suffix links. </p>
<p>Before the first step, we initialize our tree with an auxiliary state '⊥' and the root 'R'. The auxiliary state has transitions to the root for each character of the alphabet. The root has a suffix link to the auxiliary state. The auxiliary state is there to simplify the algorithm (since it has transitions for each character, it is the ultimate end point). In a real-world implementation, we would probably get rid of it. </p>
<h3>Step 1</h3>
<p>Our active point is <em>(R, ε)</em> and we look at the first character <em>a</em>. We find that the root does not have an <em>a</em>-transition (very last <code>else</code> block in the <code>test_and_split</code> routine), so we add an <em>a</em>-transition to the newly created leaf node 1 (within the main loop of the <code>update</code> routine). We follow the suffix link from the root node, which brings us to the auxiliary state. This state has all possible transitions, so it also has an <em>a</em>-transition and we're done. We didn't split any node, so no suffix link needs to be set (at the end of the <code>update</code> routine).</p>
<figure class="middle">
    <img src="/img/ukkonens_algorithm/abaabcab-1.dot.svg"/> <figcaption>
            <p>Step 1: a|baabcab#</p>
        </figcaption>
</figure>
<h3>Step 2</h3>
<p>According to lemma 2, following the <em>a</em>-transition from our previous end point, the auxiliary state, gives us the new active point with the canonic reference pair <em>(R, ε)</em>. The next steps are exactly the same as before, only for character <em>b</em>. The transition to our first state grows automatically since we use a variable tracking the length of the processed string as the second index on transitions leading up to leafs.</p>
<figure class="middle">
    <img src="/img/ukkonens_algorithm/abaabcab-2.dot.svg"/> <figcaption>
            <p>Step 2: ab|aabcab#</p>
        </figcaption>
</figure>
<h3>Step 3</h3>
<p>Our existing two transitions again grow automatically. We notice that our active point already has an <em>a</em>-transition (<code>test_and_split</code> routine), so we don't need to create a new state. Active point and end point are the same.</p>
<figure class="middle">
    <img src="/img/ukkonens_algorithm/abaabcab-3.dot.svg"/> <figcaption>
            <p>Step 3: aba|abcab#</p>
        </figcaption>
</figure>
<h3>Step 4</h3>
<p>Based on our previous end point, the new active point is <em>(R, a)</em> and we're looking at another <em>a</em>. The transition we are on continues with <em>b</em>, so we need to split it at this point (we jump into the first <code>if</code> block and then the nested <code>else</code> of <code>test_and_split</code>). We create state 3. We insert state 3 between the root and state 1 (adjusting the start index of state 1). Now we add an <em>a</em>-transition from state 3 to the second newly created state 4. We follow the suffix link to the auxiliary state and canonize it ('consuming' one symbol), which brings us back to the root. We find that there already is an <em>a</em>-transition from the root, so we reached the end point. Now we suffix-link our newly created internal state 3 to the end point, the root (final step of the <em>update</em> routine).</p>
<figure class="middle">
    <img src="/img/ukkonens_algorithm/abaabcab-4.dot.svg"/> <figcaption>
            <p>Step 4: abaa|bcab#</p>
        </figcaption>
</figure>
<h3>Step 5</h3>
<p>The new active point is <em>(3, ε)</em>. We find a <em>b</em>-transition from our active point, so again active point and end point are the same.</p>
<figure class="middle">
    <img src="/img/ukkonens_algorithm/abaabcab-5.dot.svg"/> <figcaption>
            <p>Step 5: abaab|cab#</p>
        </figcaption>
</figure>
<h3>Step 6</h3>
<p>The new active point is <em>(3, b)</em>. The transition we are on does not continue with the current character <em>c</em>, so we need to split again, as in step 4, creating states 5 and 6. We keep a reference to the new internal state 5 (to set its suffix link later) and follow the suffix link of the active point to the root, where we find the need to split the existing transition <em>baab</em> after the first <em>b</em> to add the suffix <em>bc</em>. After creating internal state 7, we can set the suffix link on state 5. We follow the suffix link from the active point (root) to the auxiliary state. Canonization 'consumes' one symbol and brings us back to the root, where we add the missing <em>c</em>-transition to the new state 9. State 7 was the last internal state created and gets a suffix link to the last canonized suffix link we followed, root. The final suffix link we follow brings us to the auxiliary state, which is the end point.</p>
<figure class="middle">
    <img src="/img/ukkonens_algorithm/abaabcab-6.dot.svg"/> <figcaption>
            <p>Step 6: abaabc|ab#</p>
        </figcaption>
</figure>
<h3>Step 7</h3>
<p>The active point is <em>(R, ε)</em> and we are looking at character <em>a</em>, for which there is already a transition. Active point and end point are the same.</p>
<figure class="middle">
    <img src="/img/ukkonens_algorithm/abaabcab-7.dot.svg"/> <figcaption>
            <p>Step 7: abaabca|b#</p>
        </figcaption>
</figure>
<h3>Step 8</h3>
<p>The canonized reference pair to the active point is <em>(3, ε)</em> and the current character is <em>b</em>, for which state 3 has a transition. Active point and endpoint are the same.</p>
<figure class="middle">
    <img src="/img/ukkonens_algorithm/abaabcab-7.dot.svg"/> <figcaption>
            <p>Step 8: abaabcab|#</p>
        </figcaption>
</figure>
<h3>Step 9</h3>
<p>The canonized reference pair to the active point is <em>(5, ε)</em> and the current character is the string terminator <em>$</em>. Because this character is unique, we have to follow the suffix links from the active point and create new states at each state on the path until we arrive at the auxiliary state, which is the end point.</p>
<figure class="middle">
    <img src="/img/ukkonens_algorithm/abaabcab-9.dot.svg"
         alt="Suffix tree for 'abaabcab'"/> <figcaption>
            <p>Step 9: abaabcab#|</p>
        </figcaption>
</figure>
<p>We're done, finally. The unique terminating character ensures that there is an explicit leaf for each suffix.</p>
<hr />
<p><a id="1" href="#fn-1"><sup>1</sup></a> Maybe I'm doing Gusfield's description injustice and the original paper only seemed clearer because I read it afterwards.</p>
<hr />
<p>Gusfield, Dan (1997). <em>Algorithms on strings, trees, and sequences: computer science and computational biology</em>. Cambridge University Press.</p>
<p>Ukkonen, E. (1995). <em>On-line construction of suffix trees</em>. Algorithmica, 14(3), 249-260.</p>

        </article>
    </main>
    <footer id="site-footer">
    <a id="footer-name" href="/">&copy; 2018-2021<br>Tobias Kolditz</a>
</footer>
    
</body>

</html>
